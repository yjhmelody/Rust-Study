// 所有程序都必须管理其运行时使用计算机内存的方式。一些语言中使用垃圾回收在程序运行
// 过程中来时刻寻找不再被使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。
// Rust 则选择了第三种方式：内存被一个所有权系统管理，它拥有一系列的规则使编译器在编
// 译时进行检查。任何所有权系统的功能都不会导致运行时开销。

// 首先，让我们看一下所有权的规则。
// 1. Rust 中每一个值都有一个称之为其 所有者（owner）的变量。
// 2. 值有且只能有一个所有者。
// 3. 当所有者（变量）离开作用域，这个值将被丢弃。

// 一个变量和其有效的作用域
// 1. 当 s 进入作用域 时，它就是有效的。
// 2. 这一直持续到它 离开作用域 为止。
// 变量是否有效与作用域的关系跟其他编程语言是类似的。

fn main() {
    let mut s = String::from("hello");
    s.push_str(" world");
    println!("{}", s);
    
    // 为什么 String 可变而字面值却不行呢？区别在于两个类型对内存的处理上
    // 对于字符串字面值的情况，我们在编译时就知道其内容所以它直接被硬编码进最终的可执行
    // 文件中，这使得字符串字面值快速且高效。不过这些属性都只来源于其不可变性。

    // 对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时
    // 未知大小的内存来存放内容。这意味着：
    // 1. 内存必须在运行时向操作系统请求。
    // 2. 需要一个当我们处理完 String 时将内存返回给操作系统的方法。

    // 在有 垃圾回收（garbage collector，GC）的语言
    // 中， GC 记录并清除不再使用的内存，而我们作为程序员，并不需要关心他们。没有 GC 的
    // 话，识别出不再使用的内存并调用代码显式释放就是我们程序员的责任了，正如请求内存的
    // 时候一样。

    // Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。

    // 在 C++ 中，这种 item 在生命周期结束时释放资源的方法有时被称作 资源获取即
    // 初始化（Resource Acquisition Is Initialization (RAII)）。如果你使用过 RAII 模式的话应
    // 该对 Rust 的 drop 函数并不陌生。

    let s1 = String::from("hello");
    let s2 = s1;
    // 为了确保内存安全，这种场景下 Rust 的处理有另一个细节值得注意。与其尝试拷贝被分配的
    // 内存，Rust 则认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。

    // 如果你在其他语言中听说过术语 “浅拷贝”（“shallow copy”）和 “深拷贝”（“deep copy”），那
    // 么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变
    // 量无效化了，这个操作被称为 移动（move），而不是浅拷贝。

    println!("{}", s2);
    let s: &[str] = "hello world";
    let e = Extrema{a:s, b:&2};
    println!("{:?}", e);
}


#[derive(Debug)]
struct Extrema<'elt> {
    a: &'elt str,
    b: &'elt i32,
}